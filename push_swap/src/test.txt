Certainly! Let's delve deeper into why we pass &stack_a and use **stack_a, and what each of these means in 
terms of memory and function argument passing.

In C, when you pass a variable to a function, you're actually passing a copy of the variable's value.
 However, when you pass a pointer, you're passing a copy of the memory address the pointer holds.
  This distinction becomes crucial when you want to modify the variable or the data it points to within a
   function. Let's break it down step by step:

Passing by Value:

When you pass a variable by value, a copy of the variable's value is made and provided to the function.
Any modifications made to the parameter within the function are local to that function and won't affect 
the original variable.
Example: int x = 5; and foo(x); where foo is a function. Any changes to x within foo won't affect x 
outside of foo.
Passing Pointers:

When you pass a pointer, you're effectively passing a copy of the memory address that the pointer holds.
This allows the function to access and modify the data the pointer points to.
However, if you want to modify the pointer itself (for example, making it point to a different memory address),
 you need to pass a pointer to the pointer.
Example: int *ptr = &x; and foo(&ptr); where foo is a function that accepts a pointer to an integer pointer (int **ptr).
 This allows foo to modify where ptr points to.
Now, let's apply this understanding to your code:

In your code, stack_a is a pointer to a t_list structure.
When you pass stack_a to swap_a as t_list *stack_a, you're passing a copy of the pointer's value. 
Any modifications to stack_a within swap_a will only affect the copy, not the original stack_a variable in the main function.
To allow swap_a to modify stack_a itself (i.e., to make it point to a different memory address), you need to pass the address of stack_a,
 i.e., &stack_a. This gives swap_a access to the original pointer variable stack_a from the main function.
Since stack_a is a pointer to a pointer, you need to declare swap_a as void swap_a(t_list **stack_a) to match the type of argument it's receiving.
Inside swap_a, to access the pointer stack_a points to, you need to dereference it using *stack_a. So,
 (*stack_a)->next accesses the next pointer of the first node in the linked list stack_a points to.
Finally, if you want to modify stack_a itself, you need to dereference it again and then assign the new value. Hence, 
*stack_a = tmp; assigns tmp to the original pointer stack_a in the main function.